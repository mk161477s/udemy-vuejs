v-model



Dataプロパティ
動的な表現ができない
あくまでも初期値を扱う

computedプロパティ
動的表現が可能、値には関数を指定する
二重中括弧とv-onディレクティブにおいて()は付けない
=> あくまでもVueの仕様として、プロパティであるかのように使用する


methodsプロパティとの違い
methodsは再描画されるたびに関数が実行されてしまう
computedは、computed内で使用している参照先（this.〇〇〇）が変わったときのみ実行する
二重中括弧においては()は付ける

v-onディレクトリにおいては()は付けても付けなくてもOK
=> そもそもJS式（インラインメソッドハンドラ）をそのまま書いてもOK

インラインメソッドハンドラ => 括弧を付ける
メソッドイベントハンドラ => 括弧は付けない（「メソッドの名前を指定できる」という条件のもと、括弧を使っていないだけ）


ウォッチャ
特定のデータが変更されたときに処理を実行する
computedプロパティと似ており、基本はcomputedを使用する
computedだけでは賄えない場合に使う
非同期通信



v-elseはv-ifもしくはv-elseifの直下に置く

v-showもv-ifと同じような処理が可能
v-showはインラインスタイルのdisplay: none;で削除する
=> templateタグは使えない、elseのような処理もできない

v-ifは要素そのものを削除する


v-showのデメリット
初期描画が遅い（trueでもfalseでも、初期の実行タイミングでDOMに追加してしまうため）

v-ifのデメリット
頻繁に切り替える場合は処理が遅い


templateタグについて
直接表示されないタグ、グループ化される

v-for
リストレンダリング



v-for="●● in 〇〇"
〇〇は配列を入れたプロパティの名前
慣例的に、●●は〇〇の単数形として定義する

v-for="(●●, index) in 〇〇"
第2引数にindexを指定すると、配列の順番を取得できる

v-for="(●●, key, index) in △△"
△△はオブジェクト名
オブジェクトのv-forは第2、3引数にキーとインデックスを取る

v-for="n in ××"
××は任意の整数値
「in」は「of」にも置き換えられる
ofはイテレータ（反復）させる
イテレータ構文

v-forディレクティブは、要素の移動を最小限に抑えるようなアルゴリズムを使用し、
可能な限りその場で同じタイプの要素を再利用しようとする性質がある。

v-for="●● in 〇〇" key="●●"
配列とv-forを指定した要素内の内容を紐づける
※templateタグは使用できない
※key属性にはindexは指定できない
※配列内で重複する値が出てきた場合は、オブジェクトにしてユニークなkeyを付ける必要がある

v-forを使うときは、予期せぬエラーを回避するため、必ずkey属性を併用する！！



Vueのインスタンスは複数作成・使用できる
Vueのインスタンスに外部からアクセスする際は、変数にインスタンスを代入する

Vueインスタンス外からプロパティを追加することは、出来るには出来るが
リアクティブなプロパティにはならない（データは変わってもDOMは変更されない）
=> Watcher（getterとsetter）が用意されないから


render関数
プロパティの値として関数を設置、returnでその関数の値を返す必要がある
引数にコンポーネントのオブジェクトを取ることもある（VueCLI）

templateプロパティ
タグごと文字列内に設置する
コード数が長くと冗長になるため基本的には使用しない？
関数の引数としてcreateElementがデフォルトで設定されている（hと略されるときもある）
ここで定義される関数は、直接DOMを操作するものではない　仮想DOM

Vue.jsを公開するときはサーバーを必要としない　静的ホスティングサービス
開発中はサーバー立てる（npm run serve）、公開中は立てない（npm run build）
=>　HMR（）

ビルド
デプロイ
Webpack
dist

Vueファイル = シングルファイルコンポーネント
単一ファイルコンポーネント

---

コンポーネントについて
・コンポーネント化する際、elプロパティはVueインスタンスの中に入れたままにしておく
・コンポーネント内のdataプロパティは、データは関数である必要がある
=> 戻り値としてオブジェクトを返す
=> 参照によって共有されてしまう。一つのメモリ（データの保管場所）を共有している。
=> データだけは別々に持っておく必要があるので、初期値の値（オブジェクト）を返すようにする。

コンポーネントのローカル登録、グローバル登録
=> 基本的にはローカル登録が一般的


Vueファイル（template、script、styleがひとまとまりになったもの）は基本的にVueCLIの中でしか使えない
VueCLIの中でWebpackというものが使われていて、Webpackのひとつの機能であるVueローダーが、Vueファイルを認識している
=> インポートされたとき、最終的にコンポーネントのオブジェクトになる

---

ローカル登録


シャドウDOM => DOMをカプセル化

---

親コンポーネントと子コンポーネントでのデータのやり取り

親から子
=> 子コンポーネントにpropsを指定、propsで指定したプロパティ名を、親コンポ―ネントで属性として利用できる
propsは配列、オブジェクトも指定できる
バリデーションの指定（type、required、default）

props名はDOMテンプレート（htmlタグ）で属性として使用する際はケバブケース（ブラウザで最初に読み込まれる）、
JSで使うときはキャメルケースで書く

---

子から親
子コンポーネント側で、送り口として$emitメソッドを指定
this.$emit("my-click", this.totalNumber + 1);
第1引数に名前（なんでも良い）
第2引数に渡したいデータ自身を入れる

親コンポーネント側で、受け口としてv-onディレクティブを指定
v-on:my-click="$event"
上記の$emitで指定した第1引数がイベント名となり、イベントが実行されると$emitが発火

$emitは子コンポーネントの好きなタイミングで、親コンポーネントのイベントを発火できる（起動スイッチみたいなもの）
=> カスタムイベントを作るもの
第2引数はあくまで起動のついでに渡すものであるため、必ず指定しなければならないわけではない
（駄々をこねる子どもみたいなイメージ？）

propsで配列とオブジェクトを渡すときは、参照渡しになるので注意
$emitで作るカスタムイベント名はケバブケースにする

---

親コンポーネント側で、子コンポーネントの記述を決める際はslotを使う
slotでも子コンポーネントに定義されているデータには親からはアクセスできない
=> スロットプロパティを使えば、子コンポーネントのデータにもアクセスできる

cssに関しては親、子どちらに指定されても適用されるが、親のほうが優先度が高い

<slot></slot>の中にフォールバックコンテンツを入れると、デフォルトのコンテンツになる

v-slotを使えば複数のslotを使用して複雑なデータを渡すことができる => 名前付きスロット
①親コンポーネントでtemplateタグを配置
②その中にhtmlタグを入れていく
③templateタグにv-slot属性を記述（v-slot:〇〇）
④子コンポーネントの、連携したいslotタグにname属性を記述（name="〇〇"）
v-slotは必ずtemplateタグ内で使用する
=> v-slotはVueの2.6.0以降から使用可能となった

templateタグ外で書かれた記述はすべてデフォルトスロットになる
=> 〇〇の部分が「default」

スロットプロパティ
子コンポーネントのデータにもアクセスできる
①子コンポーネントのslotタグにv-bindを記述
:〇〇="アクセスしたいプロパティ名"
※〇〇は任意の名前
②templateタグに「v-slot:〇〇="slotProps"」と記述することで、子コンポーネントからデータを参照できる

名前付きスロットがない場合は、コンポーネントに直接v-slotを指定できる
ただしコンポーネントに書く場合は、デフォルトスロットしかない場合しか利用できない

---

動的コンポーネント
v-bind:is=""

keep-alive キャッシュを残す

createdとか使いたいときどうするの？
↓
deactivated、activatedというライフサイクルハックが使用可能

---

lazy修飾子
対象からフォーカスが外れた時に発火

number修飾子

trim修飾子
前後の余白を消す

---

カスタムディレクティブ
v-〇〇　←〇〇を好きに作成できる

Vue.directive("border", {
  // フック関数を入力
  bind() {
    // ディレクティブが初めて対象の要素に紐付いた時
  },
  inserted() {
    // 親Nodeに挿入された時（DOMに実際に挿入された時、コンポーネントでいうマウントされた時）
  },
  update() {
    // コンポーネントが更新される度、子コンポーネントが更新される前
  },
  componentUpdated() {
    // コンポーネントが更新される度、子コンポーネントが更新された後
  },
  unbind() {
    // ディレクティブが紐づいている要素から取り除かれた時
  },
});

※bindとupdateは基本的に同じコードを書く
=> 一つの関数にしてしまう

Vue.directive("border", function(el, binding) {}

カスタムディレクティブではthisが使えない

---

フィルターとミックスイン
フィルターでもthisが使えないよ

ミックスイン => コードを共有化する
mixinの内容はcomponentによって上書きされる
ただしライフサイクルフックに関しては、mixinが先に実行され、その後にcomponent側が実行される（マージ）
グローバルミックスインはすべてのコンポーネントに適用されてしまうので要注意

---
トランジション・アニメーション

transitionコンポーネント
①消えたり現れたりする
②複数の要素の中で一つの要素が選ばれて適用される
→必ずkey属性を付与する

transitionタグは単一のコンポーネントしか扱えない

v-showは2つ使用できない
v-if、elseだと可能

<transition
      @before-enter="beforeEnter"
      @enter="Enter"
      @after-enter="afterEnter"
      @enter-cancelled="enterCancelled"
      @before-leave="beforeLeave"
      @leave="leave"
      @after-leave="afterLeave"
      @leave-cancelled="leaveCancelled"
    >

methods: {
    beforeEnter() {},
    enter() {},
    afterEnter() {},
    enterCancelled() {},
    beforeLeave() {},
    leave() {},
    afterLeave() {},
    leaveCancelled() {},
  }

8つのJSフックと引数について
done→cssとJSのアニメーションどちらも見たい、というときはつけなくてOK
JSが終わったときにCSSのアニメーションを終えたいときはつける

leaveCancelled→v-showと併用するときだけ有効

css属性にfalseを渡し、安全にJSのアニメーションを行う
:css="false"
↑v-bindをつける

